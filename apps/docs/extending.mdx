---
title: "Extending"
description: "Define commands, customize theming, and build advanced integrations"
---

## Defining commands

Most apps need commands in the palette — navigate to a page, toggle a setting, open a modal. Define them as `CommandDefinition[]` and pass them to `CommandMenu`:

```tsx
import { CommandMenu, type CommandDefinition } from "better-cmdk";
import { LayoutDashboardIcon, SettingsIcon, SunMoonIcon } from "lucide-react";

const commands: CommandDefinition[] = [
  {
    name: "dashboard",
    label: "Go to Dashboard",
    group: "Navigation",
    icon: <LayoutDashboardIcon className="size-4" />,
    shortcut: "⌘D",
    onSelect: () => router.push("/dashboard"),
  },
  {
    name: "settings",
    label: "Settings",
    group: "Navigation",
    icon: <SettingsIcon className="size-4" />,
    shortcut: "⌘,",
    onSelect: () => router.push("/settings"),
  },
  {
    name: "dark-mode",
    label: "Toggle dark mode",
    group: "Appearance",
    icon: <SunMoonIcon className="size-4" />,
    onSelect: () => document.documentElement.classList.toggle("dark"),
  },
];

<CommandMenu open={open} onOpenChange={setOpen} commands={commands} chatEndpoint="/api/chat" />
```

Commands with the same `group` string appear together under that heading. Ungrouped commands appear first.

### Good command definitions

Include a `label`, `group`, and `icon` for every command. The `label` is what users search for. The `group` organizes the palette. The `icon` makes commands scannable.

<Tabs>
  <Tab title="Good">
    ```tsx
    {
      name: "settings",
      label: "Settings",
      group: "Navigation",
      icon: <SettingsIcon className="size-4" />,
      shortcut: "⌘,",
      onSelect: () => router.push("/settings"),
    }
    ```
  </Tab>
  <Tab title="Bad">
    ```tsx
    {
      name: "settings",
      onSelect: () => router.push("/settings"),
      // No label — displays raw name "settings"
      // No group — floats outside any heading
      // No icon — harder to scan visually
    }
    ```
  </Tab>
</Tabs>

### The CommandDefinition interface

| Property | Type | Description |
|----------|------|-------------|
| `name` | `string` | Unique key (used as cmdk value for search matching) |
| `label` | `string?` | Display text (falls back to `name`) |
| `group` | `string?` | Group heading — commands with the same group appear together |
| `icon` | `ReactNode?` | Icon rendered before the label |
| `shortcut` | `string?` | Keyboard shortcut hint (right-aligned) |
| `keywords` | `string[]?` | Extra search terms beyond the label |
| `disabled` | `boolean?` | Grayed out, not selectable |
| `onSelect` | `() => void` | Called when the command is selected |

## Actions (for AI providers)

When you connect an AI platform like [modifywithai.com](https://modifywithai.com), the platform can invoke **actions** on behalf of the user. Actions are the operations the AI agent can perform — with typed parameters and optional approval gates.

You define actions through your provider's SDK (e.g. `ActionDefinition` from modifywithai), not through better-cmdk directly. The provider passes them to `CommandMenu` via the `ExternalChat.agenticActions` field, where they also appear as searchable items in the palette.

<Tip>
  For details on defining actions, see the [modifywithai actions guide](https://modifywithai.com/docs/concepts/actions). The modifywithai agent uses action descriptions to decide when to invoke them — specific descriptions produce better results.
</Tip>

### The CommandAction interface

This is the provider-facing contract that better-cmdk expects. Providers like modifywithai map their types to this interface automatically.

| Property | Type | Description |
|----------|------|-------------|
| `name` | `string` | Unique action identifier |
| `label` | `string?` | Display label (falls back to `name`) |
| `options` | `Record<string, CommandActionOption>?` | Parameters the action accepts |
| `execute` | `(options: Record<string, unknown>) => void` | Callback when the action runs |

## Commands vs actions

| | Commands | Actions |
|---|---|---|
| **Who defines them** | You (the app developer) | Your AI provider (e.g. modifywithai) |
| **Type** | `CommandDefinition` | `CommandAction` (provider interface) |
| **Passed via** | `CommandMenu commands={...}` | `ExternalChat.agenticActions` (through provider) |
| **UI** | Icons, shortcuts, groups, keywords, disabled state | Label only |
| **On select** | Runs `onSelect()` immediately | Starts a chat, AI invokes with parameters |
| **AI-aware** | No — palette UI only | Yes — the AI agent can invoke them |

<Tip>
  Use **commands** for everything users do directly (navigate, toggle, open). **Actions** come through your AI provider — see the [modifywithai docs](https://modifywithai.com/docs/concepts/actions) for how to define them.
</Tip>

## Render function pattern (shadcn/cmdk compatible)

For full control over rendering, pass a render function as `children` instead of the `commands` prop. This is the shadcn/cmdk-compatible pattern.

```tsx
<CommandMenu open={open} onOpenChange={setOpen} chatEndpoint="/api/chat">
  {({ mode, messages, status, isEnabled }) => (
    <>
      <CommandMenuInput placeholder="Search or ask AI..." showSendButton />
      <CommandMenuList>
        <CommandMenuEmpty />
        {mode === "command" && (
          <CommandGroup heading="Navigation">
            <CommandItem onSelect={() => router.push("/dashboard")}>
              Dashboard
            </CommandItem>
            <CommandItem onSelect={() => router.push("/settings")}>
              Settings
            </CommandItem>
          </CommandGroup>
        )}
      </CommandMenuList>
    </>
  )}
</CommandMenu>
```

The render function receives:

| Property | Type | Description |
|----------|------|-------------|
| `mode` | `"command" \| "chat"` | Current mode |
| `messages` | `UIMessage[]` | Chat message history |
| `status` | `"idle" \| "submitted" \| "streaming" \| "error"` | Chat status |
| `isEnabled` | `boolean` | Whether AI chat is configured |

## Tool approval workflow

Some actions shouldn't run without confirmation. Deleting data or sending emails should require the user to approve first. better-cmdk handles this with the `Confirmation` component family.

The flow:

1. The AI sends a `tool-performActions` message part listing the actions it wants to run
2. `AssistantMessages` renders a `Confirmation` dialog showing the actions
3. The user clicks **Approve** or **Deny**
4. `addToolApprovalResponse({ id, approved: true/false })` sends the decision back to the AI

This happens automatically when you use `AssistantMessages` (which `CommandMenuList` uses internally in chat mode). If you're building a custom chat UI, compose the confirmation components yourself:

```tsx
import {
  Confirmation,
  ConfirmationTitle,
  ConfirmationRequest,
  ConfirmationAccepted,
  ConfirmationRejected,
  ConfirmationActions,
  ConfirmationAction,
} from "better-cmdk";

<Confirmation state={toolState} approval={approval}>
  <ConfirmationTitle>Confirm action</ConfirmationTitle>

  <ConfirmationRequest>
    {/* Shown while waiting for user decision */}
    <p>The AI wants to update your theme to dark mode.</p>
  </ConfirmationRequest>

  <ConfirmationAccepted>
    <p>Action approved</p>
  </ConfirmationAccepted>

  <ConfirmationRejected>
    <p>Action cancelled</p>
  </ConfirmationRejected>

  <ConfirmationActions>
    <ConfirmationAction variant="outline" onClick={() => deny(approval.id)}>
      Deny
    </ConfirmationAction>
    <ConfirmationAction onClick={() => approve(approval.id)}>
      Approve
    </ConfirmationAction>
  </ConfirmationActions>
</Confirmation>
```

The `Confirmation` component renders conditionally based on state — amber during `approval-requested`, green when approved, red when rejected.

## Context and hooks

Access command menu state from anywhere in your component tree. Useful when you need to trigger the palette programmatically or read the current mode.

```tsx
import { CommandMenuProvider, useCommandMenuContext } from "better-cmdk";

function MyCustomInput() {
  const {
    mode,           // "command" | "chat"
    inputValue,     // Current input text
    setInputValue,  // Update input
    switchToChat,   // Switch to chat mode (optional initial query)
    switchToCommand, // Switch back to command mode
    sendMessage,    // Send a chat message
    messages,       // Chat history
    status,         // "idle" | "submitted" | "streaming" | "error"
    isLoading,      // true when submitted or streaming
    isEnabled,      // true when chat is configured
  } = useCommandMenuContext();

  return <input value={inputValue} onChange={(e) => setInputValue(e.target.value)} />;
}
```

The provider is set up automatically by `CommandMenu`. If you need to use the context outside of `CommandMenu`, wrap your tree with `CommandMenuProvider`:

```tsx
<CommandMenuProvider chatEndpoint="/api/chat" onModeChange={(mode) => console.log(mode)}>
  <MyCustomInput />
  <MyCustomList />
</CommandMenuProvider>
```

### Provider props

| Prop | Type | Description |
|------|------|-------------|
| `chatEndpoint` | `string?` | API endpoint for internal Vercel AI SDK chat |
| `chat` | `ExternalChat?` | External chat provider (overrides `chatEndpoint`) |
| `onModeChange` | `(mode: CommandMenuMode) => void` | Called when mode switches |
| `onOpenChange` | `(open: boolean) => void` | Called when the menu opens/closes |

## Theming and styling

### CSS variables

better-cmdk uses namespaced CSS variables. Override them to match your brand:

```css
.bcmdk-root {
  --bcmdk-primary: 0.205 0 0;             /* Button and accent color */
  --bcmdk-primary-foreground: 0.985 0 0;  /* Text on primary */
  --bcmdk-popover: 1 0 0;                 /* Palette background */
  --bcmdk-muted: 0.97 0 0;                /* Subtle backgrounds */
  --bcmdk-border: 0.922 0 0;              /* Border color */
  --bcmdk-radius: 0.625rem;               /* Corner radius */
}
```

For dark mode, redefine these variables under `.dark .bcmdk-root`.

### className props

Every component accepts a `className` prop for one-off overrides:

```tsx
<CommandMenuInput className="text-lg" placeholder="Search..." />
```

### cn() utility

Use the `cn()` utility to merge Tailwind classes safely:

```tsx
import { cn } from "better-cmdk";

<div className={cn("p-4", isActive && "bg-primary text-primary-foreground")} />
```

## Component reference

<Accordion title="Command palette">
  | Component | Description |
  |-----------|-------------|
  | `Command` | Root command primitive |
  | `CommandDialog` | Modal command palette |
  | `CommandInput` | Search input with icon |
  | `CommandList` | Scrollable results container |
  | `CommandEmpty` | "No results" state |
  | `CommandGroup` | Groups commands with a heading |
  | `CommandItem` | Selectable command row |
  | `CommandShortcut` | Keyboard shortcut hint |
  | `CommandSeparator` | Visual divider |
</Accordion>

<Accordion title="Command menu (AI-enabled)">
  | Component | Description |
  |-----------|-------------|
  | `CommandMenu` | Dual-mode command + chat palette |
  | `CommandMenuInput` | Input with mode-aware icon and send button |
  | `CommandMenuList` | List that switches between commands and chat |
  | `CommandMenuEmpty` | "Ask AI" fallback when no commands match |
  | `CommandMenuContent` | Dialog content wrapper |
</Accordion>

<Accordion title="Chat">
  | Component | Description |
  |-----------|-------------|
  | `ChatMessageList` | Auto-scrolling message container |
  | `ChatLoading` | Streaming indicator |
  | `ChatEmpty` | Empty chat state |
</Accordion>

<Accordion title="Messages">
  | Component | Description |
  |-----------|-------------|
  | `Message` | Message wrapper (user or assistant) |
  | `MessageContent` | Message body |
  | `MessageResponse` | Markdown-rendered response (uses Streamdown) |
  | `AssistantMessages` | Full message thread with tool/form handling |
</Accordion>

<Accordion title="Confirmation">
  | Component | Description |
  |-----------|-------------|
  | `Confirmation` | Root wrapper — renders based on approval state |
  | `ConfirmationTitle` | Heading text |
  | `ConfirmationRequest` | Shown during approval request |
  | `ConfirmationAccepted` | Shown when approved |
  | `ConfirmationRejected` | Shown when rejected |
  | `ConfirmationActions` | Button container |
  | `ConfirmationAction` | Approve/deny button |
</Accordion>

<Accordion title="Task">
  | Component | Description |
  |-----------|-------------|
  | `Task` | Collapsible task wrapper |
  | `TaskTrigger` | Header with title and icon |
  | `TaskContent` | Expandable content area |
  | `TaskItem` | Individual task line |
  | `TaskItemFile` | File badge |
</Accordion>

<Accordion title="Forms">
  | Component | Description |
  |-----------|-------------|
  | `AssistantFormRenderer` | Renders AI-generated forms from JSON UI trees |
  | `defaultFormRegistry` | Default component registry for form fields |
</Accordion>

<Accordion title="Utilities">
  | Export | Description |
  |--------|-------------|
  | `Button` | Styled button with variant and size props |
  | `buttonVariants` | CVA variant definitions |
  | `cn` | Class name merger (`clsx` + `tailwind-merge`) |
  | `Dialog` / `DialogContent` / etc. | Radix UI dialog primitives |
  | `Collapsible` / `CollapsibleTrigger` / `CollapsibleContent` | Radix UI collapsible |
</Accordion>

<Accordion title="Context and hooks">
  | Export | Description |
  |--------|-------------|
  | `CommandMenuProvider` | Context provider for command menu state |
  | `CommandMenuContext` | Raw React context |
  | `useCommandMenuContext` | Hook to access command menu state |
</Accordion>

## Next steps

<CardGroup cols={2}>
  <Card title="modifywithai Integration" icon="plug" href="https://modifywithai.com/docs">
    Set up the agent platform that powers your AI actions.
  </Card>
  <Card title="GitHub" icon="github" href="https://github.com/nichochar/better-cmdk">
    View the source, file issues, and contribute.
  </Card>
</CardGroup>
